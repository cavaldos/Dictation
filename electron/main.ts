import { app, BrowserWindow, ipcMain } from 'electron'
import { fileURLToPath } from 'node:url'
import path from 'node:path'
import { getSubtitles } from 'youtube-captions-scraper'
import Store from 'electron-store'
import dotenv from 'dotenv'
import * as gemini from './ai/gemini.js'
import * as groq from './ai/groq.js'

const __dirname = path.dirname(fileURLToPath(import.meta.url))

// Load .env from project root
dotenv.config({ path: path.join(__dirname, '../.env') })

// Initialize electron-store for persistent storage
const store = new Store({
  name: 'redux-persist',
  defaults: {}
})

// Separate store for API keys (more secure)
const apiKeyStore = new Store({
  name: 'api-keys',
  defaults: {
    gemini: '',
    groq: ''
  }
})

// Load stored API keys on startup
const storedGeminiKey = apiKeyStore.get('gemini') as string
const storedGroqKey = apiKeyStore.get('groq') as string
if (storedGeminiKey) {
  gemini.setApiKey(storedGeminiKey)
}
if (storedGroqKey) {
  groq.setApiKey(storedGroqKey)
}

// AI provider state
let currentProvider = 'gemini' // 'gemini' or 'groq'
const aiProviders = [
  { id: 'gemini', name: 'Gemini', currentModel: gemini.getModel() },
  { id: 'groq', name: 'Groq', currentModel: groq.getGroqModel() },
]

process.env.DIST_ELECTRON = path.join(__dirname, '..')
process.env.DIST = path.join(__dirname, '../dist-electron')

let win: BrowserWindow | null = null

// IPC handler to fetch YouTube captions list (bypasses CORS)
ipcMain.handle('fetch-youtube-captions', async (_event, videoId: string) => {
  try {
    const response = await fetch(`https://www.youtube.com/watch?v=${videoId}`)
    const html = await response.text()
    
    // Extract captionTracks from YouTube page
    const match = html.match(/"captionTracks":\s*(\[[^\]]+\])/)
    if (!match) {
      return { success: false, captions: [], error: 'No captions found' }
    }

    try {
      // Clean up the JSON string (handle unicode escapes)
      const jsonStr = match[1].replace(/\\u0026/g, '&')
      const tracks = JSON.parse(jsonStr)
      
      const captions = tracks.map((track: { 
        languageCode: string; 
        name?: { simpleText?: string }; 
        kind?: string;
        vssId?: string;
      }) => ({
        languageCode: track.languageCode,
        languageName: track.name?.simpleText || track.languageCode,
        isAutoGenerated: track.kind === 'asr' || track.vssId?.startsWith('a.'),
      }))

      return { success: true, captions }
    } catch (parseError) {
      console.error('Failed to parse captions:', parseError)
      return { success: false, captions: [], error: 'Failed to parse captions' }
    }
  } catch (error) {
    console.error('Failed to fetch YouTube page:', error)
    return { success: false, captions: [], error: 'Failed to fetch video info' }
  }
})

// IPC handler to fetch subtitles content (bypasses CORS)
ipcMain.handle('fetch-youtube-subtitles', async (_event, videoId: string, lang: string) => {
  try {
    const captions = await getSubtitles({
      videoID: videoId,
      lang: lang,
    })

    const subtitles = captions.map((caption: { start: string | number; dur: string | number; text: string }) => ({
      start: parseFloat(String(caption.start)),
      dur: parseFloat(String(caption.dur)),
      text: caption.text,
    }))

    return { success: true, subtitles }
  } catch (error) {
    console.error('Failed to fetch subtitles:', error)
    return { success: false, subtitles: [], error: `Could not fetch subtitles for language: ${lang}` }
  }
})

// IPC handlers for electron-store (redux-persist storage)
ipcMain.handle('electron-store-get', async (_event, key: string) => {
  try {
    const value = store.get(key)
    return value !== undefined ? JSON.stringify(value) : null
  } catch (error) {
    console.error('electron-store-get error:', error)
    return null
  }
})

ipcMain.handle('electron-store-set', async (_event, key: string, value: string) => {
  try {
    store.set(key, JSON.parse(value))
    return true
  } catch (error) {
    console.error('electron-store-set error:', error)
    return false
  }
})

ipcMain.handle('electron-store-remove', async (_event, key: string) => {
  try {
    store.delete(key)
    return true
  } catch (error) {
    console.error('electron-store-remove error:', error)
    return false
  }
})

// AI Chat IPC handlers
ipcMain.handle('get-ai-providers', async () => {
  try {
    return {
      success: true,
      data: {
        providers: aiProviders,
        currentProvider: currentProvider
      }
    }
  } catch (error) {
    console.error('get-ai-providers error:', error)
    return { success: false, error: 'Failed to get AI providers' }
  }
})

ipcMain.handle('set-ai-provider', async (_event, providerId: string) => {
  try {
    if (!aiProviders.find(p => p.id === providerId)) {
      return { success: false, error: 'Invalid provider ID' }
    }
    currentProvider = providerId
    return { success: true }
  } catch (error) {
    console.error('set-ai-provider error:', error)
    return { success: false, error: 'Failed to set AI provider' }
  }
})

ipcMain.handle('fetch-ai-models', async (_event, providerId: string) => {
  try {
    let models: Array<{id: string, name: string, description: string}> = []
    if (providerId === 'gemini') {
      models = await gemini.listGeminiModels()
    } else if (providerId === 'groq') {
      models = await groq.listGroqModels()
    } else {
      return { success: false, error: 'Invalid provider ID' }
    }
    return { success: true, data: models }
  } catch (error) {
    console.error('fetch-ai-models error:', error)
    return { success: false, error: 'Failed to fetch models' }
  }
})

ipcMain.handle('set-ai-model', async (_event, providerId: string, modelId: string) => {
  try {
    if (providerId === 'gemini') {
      gemini.setModel(modelId)
      const provider = aiProviders.find(p => p.id === 'gemini')
      if (provider) provider.currentModel = modelId
    } else if (providerId === 'groq') {
      groq.setGroqModel(modelId)
      const provider = aiProviders.find(p => p.id === 'groq')
      if (provider) provider.currentModel = modelId
    } else {
      return { success: false, error: 'Invalid provider ID' }
    }
    return { success: true }
  } catch (error) {
    console.error('set-ai-model error:', error)
    return { success: false, error: 'Failed to set model' }
  }
})

ipcMain.handle('chat-with-ai-stream', async (event, history: Array<{role: string, content: string}>, message: string, systemPrompt?: string) => {
  try {
    let fullResponse = ''
    
    const onChunk = (chunk: string) => {
      event.sender.send('ai-chat-chunk', chunk)
    }
    
    if (currentProvider === 'gemini') {
      fullResponse = await gemini.chatWithGeminiStream(history, message, onChunk, systemPrompt)
    } else if (currentProvider === 'groq') {
      fullResponse = await groq.chatWithGroqStream(history, message, onChunk, systemPrompt)
    } else {
      return { success: false, error: 'Invalid provider' }
    }
    
    return { success: true, data: fullResponse }
  } catch (error) {
    console.error('chat-with-ai-stream error:', error)
    return { success: false, error: (error as Error).message }
  }
})

// API Key Management IPC handlers
ipcMain.handle('get-api-key-status', async () => {
  try {
    const envGeminiKey = process.env.GOOGLE_API_KEY
    const envGroqKey = process.env.GROQ_API_KEY
    const storedGeminiKey = apiKeyStore.get('gemini') as string
    const storedGroqKey = apiKeyStore.get('groq') as string

    return {
      success: true,
      data: {
        gemini: envGeminiKey ? 'env' : (storedGeminiKey ? 'custom' : 'unconfigured'),
        groq: envGroqKey ? 'env' : (storedGroqKey ? 'custom' : 'unconfigured')
      }
    }
  } catch (error) {
    console.error('get-api-key-status error:', error)
    return { success: false, error: 'Failed to get API key status' }
  }
})

ipcMain.handle('get-api-keys', async () => {
  try {
    return {
      success: true,
      data: {
        gemini: apiKeyStore.get('gemini') as string || '',
        groq: apiKeyStore.get('groq') as string || ''
      }
    }
  } catch (error) {
    console.error('get-api-keys error:', error)
    return { success: false, error: 'Failed to get API keys' }
  }
})

ipcMain.handle('set-api-key', async (_event, provider: 'gemini' | 'groq', key: string) => {
  try {
    apiKeyStore.set(provider, key)
    
    // Update the AI module with the new key
    if (provider === 'gemini') {
      gemini.setApiKey(key)
    } else if (provider === 'groq') {
      groq.setApiKey(key)
    }
    
    return { success: true }
  } catch (error) {
    console.error('set-api-key error:', error)
    return { success: false, error: 'Failed to set API key' }
  }
})

ipcMain.handle('remove-api-key', async (_event, provider: 'gemini' | 'groq') => {
  try {
    apiKeyStore.set(provider, '')
    
    // Reset the AI module to use env key
    if (provider === 'gemini') {
      gemini.setApiKey('')
    } else if (provider === 'groq') {
      groq.setApiKey('')
    }
    
    return { success: true }
  } catch (error) {
    console.error('remove-api-key error:', error)
    return { success: false, error: 'Failed to remove API key' }
  }
})

ipcMain.handle('test-api-key', async (_event, provider: 'gemini' | 'groq') => {
  try {
    if (provider === 'gemini') {
      await gemini.testConnection()
    } else if (provider === 'groq') {
      await groq.testConnection()
    }
    return { success: true }
  } catch (error) {
    console.error('test-api-key error:', error)
    return { success: false, error: (error as Error).message }
  }
})

// Validate API key without saving (test with provided key)
ipcMain.handle('validate-api-key', async (_event, provider: 'gemini' | 'groq', key: string) => {
  try {
    if (provider === 'gemini') {
      await gemini.validateKey(key)
    } else if (provider === 'groq') {
      await groq.validateKey(key)
    }
    return { success: true }
  } catch (error) {
    console.error('validate-api-key error:', error)
    return { success: false, error: (error as Error).message }
  }
})


function createWindow() {
  win = new BrowserWindow({
    width: 1200,
    height: 800,
    titleBarStyle: 'hiddenInset', // macOS: ẩn title bar, giữ traffic lights
    trafficLightPosition: { x: 12, y: 12 }, // Vị trí nút đỏ/vàng/xanh
    backgroundColor: '#191919', // Màu nền trùng với app background
    webPreferences: {
      preload: path.join(__dirname, 'preload.js'),
      contextIsolation: true,
      nodeIntegration: false,
      sandbox: false,
      webSecurity: true,
    },
  })

  // Allow YouTube iframe to embed by removing restrictive headers
  win.webContents.session.webRequest.onHeadersReceived((details, callback) => {
    const responseHeaders = { ...details.responseHeaders }
    
    // Remove headers that might block YouTube iframe
    delete responseHeaders['X-Frame-Options']
    delete responseHeaders['x-frame-options']
    delete responseHeaders['Content-Security-Policy']
    delete responseHeaders['content-security-policy']
    
    callback({ responseHeaders })
  })

  if (process.env.VITE_DEV_SERVER_URL) {
    win.loadURL(process.env.VITE_DEV_SERVER_URL)
    win.webContents.openDevTools()
  } else {
    const distElectron = process.env.DIST_ELECTRON
    if (distElectron) {
      win.loadFile(path.join(distElectron, 'dist/index.html'))
    }
  }
}

app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit()
  }
})

app.on('activate', () => {
  if (win === null) {
    createWindow()
  }
})

app.whenReady().then(() => {
  createWindow()
})
