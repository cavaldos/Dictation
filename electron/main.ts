import { app, BrowserWindow, ipcMain } from 'electron'
import { fileURLToPath } from 'node:url'
import path from 'node:path'
import { getSubtitles } from 'youtube-captions-scraper'

const __dirname = path.dirname(fileURLToPath(import.meta.url))

process.env.DIST_ELECTRON = path.join(__dirname, '..')
process.env.DIST = path.join(__dirname, '../dist-electron')

let win: BrowserWindow | null = null

// IPC handler to fetch YouTube captions list (bypasses CORS)
ipcMain.handle('fetch-youtube-captions', async (_event, videoId: string) => {
  try {
    const response = await fetch(`https://www.youtube.com/watch?v=${videoId}`)
    const html = await response.text()
    
    // Extract captionTracks from YouTube page
    const match = html.match(/"captionTracks":\s*(\[[^\]]+\])/)
    if (!match) {
      return { success: false, captions: [], error: 'No captions found' }
    }

    try {
      // Clean up the JSON string (handle unicode escapes)
      const jsonStr = match[1].replace(/\\u0026/g, '&')
      const tracks = JSON.parse(jsonStr)
      
      const captions = tracks.map((track: { 
        languageCode: string; 
        name?: { simpleText?: string }; 
        kind?: string;
        vssId?: string;
      }) => ({
        languageCode: track.languageCode,
        languageName: track.name?.simpleText || track.languageCode,
        isAutoGenerated: track.kind === 'asr' || track.vssId?.startsWith('a.'),
      }))

      return { success: true, captions }
    } catch (parseError) {
      console.error('Failed to parse captions:', parseError)
      return { success: false, captions: [], error: 'Failed to parse captions' }
    }
  } catch (error) {
    console.error('Failed to fetch YouTube page:', error)
    return { success: false, captions: [], error: 'Failed to fetch video info' }
  }
})

// IPC handler to fetch subtitles content (bypasses CORS)
ipcMain.handle('fetch-youtube-subtitles', async (_event, videoId: string, lang: string) => {
  try {
    const captions = await getSubtitles({
      videoID: videoId,
      lang: lang,
    })

    const subtitles = captions.map((caption: { start: string | number; dur: string | number; text: string }) => ({
      start: parseFloat(String(caption.start)),
      dur: parseFloat(String(caption.dur)),
      text: caption.text,
    }))

    return { success: true, subtitles }
  } catch (error) {
    console.error('Failed to fetch subtitles:', error)
    return { success: false, subtitles: [], error: `Could not fetch subtitles for language: ${lang}` }
  }
})

function createWindow() {
  win = new BrowserWindow({
    width: 1200,
    height: 800,
    titleBarStyle: 'hiddenInset', // macOS: ẩn title bar, giữ traffic lights
    trafficLightPosition: { x: 12, y: 12 }, // Vị trí nút đỏ/vàng/xanh
    backgroundColor: '#191919', // Màu nền trùng với app background
    webPreferences: {
      preload: path.join(__dirname, 'preload.js'),
      contextIsolation: true,
      nodeIntegration: false,
      sandbox: false,
      webSecurity: true,
    },
  })

  // Allow YouTube iframe to embed by removing restrictive headers
  win.webContents.session.webRequest.onHeadersReceived((details, callback) => {
    const responseHeaders = { ...details.responseHeaders }
    
    // Remove headers that might block YouTube iframe
    delete responseHeaders['X-Frame-Options']
    delete responseHeaders['x-frame-options']
    delete responseHeaders['Content-Security-Policy']
    delete responseHeaders['content-security-policy']
    
    callback({ responseHeaders })
  })

  if (process.env.VITE_DEV_SERVER_URL) {
    win.loadURL(process.env.VITE_DEV_SERVER_URL)
    win.webContents.openDevTools()
  } else {
    const distElectron = process.env.DIST_ELECTRON
    if (distElectron) {
      win.loadFile(path.join(distElectron, 'dist/index.html'))
    }
  }
}

app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit()
  }
})

app.on('activate', () => {
  if (win === null) {
    createWindow()
  }
})

app.whenReady().then(() => {
  createWindow()
})
